/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/metaKey, or arrow keys / touch: two-finger move

THREE.OrbitControls = function (e, t) { var n, o, a, i, s; this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.target = new THREE.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }, this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function () { return d.phi }, this.getAzimuthalAngle = function () { return d.theta }, this.setPolarAngle = function (e) { d.phi = e, this.forceUpdate() }, this.setAzimuthalAngle = function (e) { d.theta = e, this.forceUpdate() }, this.saveState = function () { r.target0.copy(r.target), r.position0.copy(r.object.position), r.zoom0 = r.object.zoom }, this.reset = function () { r.target.copy(r.target0), r.object.position.copy(r.position0), r.object.zoom = r.zoom0, r.object.updateProjectionMatrix(), r.dispatchEvent(c), r.update(), u = m.NONE }, this.forceUpdate = (n = new THREE.Vector3, o = (new THREE.Quaternion).setFromUnitVectors(e.up, new THREE.Vector3(0, 1, 0)), a = o.clone().inverse(), i = new THREE.Vector3, s = new THREE.Quaternion, function () { var e = this.object.position; n.copy(e).sub(this.target), n.applyQuaternion(o), d.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, d.theta)), d.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, d.phi)), d.phi = Math.max(p, Math.min(Math.PI - p, d.phi)); var t = n.length() * b; return t = Math.max(this.minDistance, Math.min(this.maxDistance, t)), this.target.add(g), n.x = t * Math.sin(d.phi) * Math.sin(d.theta), n.y = t * Math.cos(d.phi), n.z = t * Math.sin(d.phi) * Math.cos(d.theta), n.applyQuaternion(a), e.copy(this.target).add(n), this.object.lookAt(this.target), !0 === this.enableDamping ? (d.thetaDelta *= 1 - this.dampingFactor, d.phiDelta *= 1 - this.dampingFactor) : (d.thetaDelta = 0, d.phiDelta = 0), b = 1, g.set(0, 0, 0), !!(f || i.distanceToSquared(this.object.position) > p || 8 * (1 - s.dot(this.object.quaternion)) > p) && (i.copy(this.object.position), s.copy(this.object.quaternion), f = !1, !0) }), this.update = function () { var t = new THREE.Vector3, n = (new THREE.Quaternion).setFromUnitVectors(e.up, new THREE.Vector3(0, 1, 0)), o = n.clone().inverse(), a = new THREE.Vector3, i = new THREE.Quaternion; return function () { var e = r.object.position; return t.copy(e).sub(r.target), t.applyQuaternion(n), d.setFromVector3(t), r.autoRotate && u === m.NONE && A(2 * Math.PI / 60 / 60 * r.autoRotateSpeed), d.theta += E.theta, d.phi += E.phi, d.theta = Math.max(r.minAzimuthAngle, Math.min(r.maxAzimuthAngle, d.theta)), d.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, d.phi)), d.makeSafe(), d.radius *= b, d.radius = Math.max(r.minDistance, Math.min(r.maxDistance, d.radius)), r.target.add(g), t.setFromSpherical(d), t.applyQuaternion(o), e.copy(r.target).add(t), r.object.lookAt(r.target), !0 === r.enableDamping ? (E.theta *= 1 - r.dampingFactor, E.phi *= 1 - r.dampingFactor, g.multiplyScalar(1 - r.dampingFactor)) : (E.set(0, 0, 0), g.set(0, 0, 0)), b = 1, !!(f || a.distanceToSquared(r.object.position) > p || 8 * (1 - i.dot(r.object.quaternion)) > p) && (r.dispatchEvent(c), a.copy(r.object.position), i.copy(r.object.quaternion), f = !1, !0) } }(), this.dispose = function () { r.domElement.removeEventListener("contextmenu", _, !1), r.domElement.removeEventListener("mousedown", U, !1), r.domElement.removeEventListener("wheel", Y, !1), r.domElement.removeEventListener("touchstart", I, !1), r.domElement.removeEventListener("touchend", K, !1), r.domElement.removeEventListener("touchmove", X, !1), document.removeEventListener("mousemove", z, !1), document.removeEventListener("mouseup", F, !1), window.removeEventListener("keydown", Z, !1) }; var r = this, c = { type: "change" }, h = { type: "start" }, l = { type: "end" }, m = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 }, u = m.NONE, p = 1e-6, d = new THREE.Spherical, E = new THREE.Spherical, b = 1, g = new THREE.Vector3, f = !1, T = new THREE.Vector2, y = new THREE.Vector2, v = new THREE.Vector2, R = new THREE.Vector2, H = new THREE.Vector2, O = new THREE.Vector2, w = new THREE.Vector2, P = new THREE.Vector2, j = new THREE.Vector2; function M() { return Math.pow(.95, r.zoomSpeed) } function A(e) { E.theta -= e } function L(e) { E.phi -= e } var D, x = (D = new THREE.Vector3, function (e, t) { D.setFromMatrixColumn(t, 0), D.multiplyScalar(-e), g.add(D) }), C = function () { var e = new THREE.Vector3; return function (t, n) { !0 === r.screenSpacePanning ? e.setFromMatrixColumn(n, 1) : (e.setFromMatrixColumn(n, 0), e.crossVectors(r.object.up, e)), e.multiplyScalar(t), g.add(e) } }(), N = function () { var e = new THREE.Vector3; return function (t, n) { var o = r.domElement === document ? r.domElement.body : r.domElement; if (r.object.isPerspectiveCamera) { var a = r.object.position; e.copy(a).sub(r.target); var i = e.length(); i *= Math.tan(r.object.fov / 2 * Math.PI / 180), x(2 * t * i / o.clientHeight, r.object.matrix), C(2 * n * i / o.clientHeight, r.object.matrix) } else r.object.isOrthographicCamera ? (x(t * (r.object.right - r.object.left) / r.object.zoom / o.clientWidth, r.object.matrix), C(n * (r.object.top - r.object.bottom) / r.object.zoom / o.clientHeight, r.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r.enablePan = !1) } }(); function S(e) { r.object.isPerspectiveCamera ? b /= e : r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom * e)), r.object.updateProjectionMatrix(), f = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1) } function k(e) { r.object.isPerspectiveCamera ? b *= e : r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / e)), r.object.updateProjectionMatrix(), f = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1) } function V(e) { R.set(e.clientX, e.clientY) } function U(e) { if (!1 !== r.enabled) { switch (e.preventDefault(), e.button) { case r.mouseButtons.LEFT: if (e.ctrlKey || e.metaKey) { if (!1 === r.enablePan) return; V(e), u = m.PAN } else { if (!1 === r.enableRotate) return; !function (e) { T.set(e.clientX, e.clientY) }(e), u = m.ROTATE } break; case r.mouseButtons.MIDDLE: if (!1 === r.enableZoom) return; !function (e) { w.set(e.clientX, e.clientY) }(e), u = m.DOLLY; break; case r.mouseButtons.RIGHT: if (!1 === r.enablePan) return; V(e), u = m.PAN }u !== m.NONE && (document.addEventListener("mousemove", z, !1), document.addEventListener("mouseup", F, !1), r.dispatchEvent(h)) } } function z(e) { if (!1 !== r.enabled) switch (e.preventDefault(), u) { case m.ROTATE: if (!1 === r.enableRotate) return; !function (e) { y.set(e.clientX, e.clientY), v.subVectors(y, T).multiplyScalar(r.rotateSpeed); var t = r.domElement === document ? r.domElement.body : r.domElement; A(2 * Math.PI * v.x / t.clientHeight), L(2 * Math.PI * v.y / t.clientHeight), T.copy(y), r.update() }(e); break; case m.DOLLY: if (!1 === r.enableZoom) return; !function (e) { P.set(e.clientX, e.clientY), j.subVectors(P, w), j.y > 0 ? S(M()) : j.y < 0 && k(M()), w.copy(P), r.update() }(e); break; case m.PAN: if (!1 === r.enablePan) return; !function (e) { H.set(e.clientX, e.clientY), O.subVectors(H, R).multiplyScalar(r.panSpeed), N(O.x, O.y), R.copy(H), r.update() }(e) } } function F(e) { !1 !== r.enabled && (document.removeEventListener("mousemove", z, !1), document.removeEventListener("mouseup", F, !1), r.dispatchEvent(l), u = m.NONE) } function Y(e) { !1 === r.enabled || !1 === r.enableZoom || u !== m.NONE && u !== m.ROTATE || (e.preventDefault(), e.stopPropagation(), r.dispatchEvent(h), function (e) { e.deltaY < 0 ? k(M()) : e.deltaY > 0 && S(M()), r.update() }(e), r.dispatchEvent(l)) } function Z(e) { !1 !== r.enabled && !1 !== r.enableKeys && !1 !== r.enablePan && function (e) { switch (e.keyCode) { case r.keys.UP: N(0, r.keyPanSpeed), r.update(); break; case r.keys.BOTTOM: N(0, -r.keyPanSpeed), r.update(); break; case r.keys.LEFT: N(r.keyPanSpeed, 0), r.update(); break; case r.keys.RIGHT: N(-r.keyPanSpeed, 0), r.update() } }(e) } function I(e) { if (!1 !== r.enabled) { switch (e.preventDefault(), e.touches.length) { case 1: if (!1 === r.enableRotate) return; !function (e) { T.set(e.touches[0].pageX, e.touches[0].pageY) }(e), u = m.TOUCH_ROTATE; break; case 2: if (!1 === r.enableZoom && !1 === r.enablePan) return; !function (e) { if (r.enableZoom) { var t = e.touches[0].pageX - e.touches[1].pageX, n = e.touches[0].pageY - e.touches[1].pageY, o = Math.sqrt(t * t + n * n); w.set(0, o) } if (r.enablePan) { var a = .5 * (e.touches[0].pageX + e.touches[1].pageX), i = .5 * (e.touches[0].pageY + e.touches[1].pageY); R.set(a, i) } }(e), u = m.TOUCH_DOLLY_PAN; break; default: u = m.NONE }u !== m.NONE && r.dispatchEvent(h) } } function X(e) { if (!1 !== r.enabled) switch (e.preventDefault(), e.stopPropagation(), e.touches.length) { case 1: if (!1 === r.enableRotate) return; if (u !== m.TOUCH_ROTATE) return; !function (e) { y.set(e.touches[0].pageX, e.touches[0].pageY), v.subVectors(y, T).multiplyScalar(r.rotateSpeed); var t = r.domElement === document ? r.domElement.body : r.domElement; A(2 * Math.PI * v.x / t.clientHeight), L(2 * Math.PI * v.y / t.clientHeight), T.copy(y), r.update() }(e); break; case 2: if (!1 === r.enableZoom && !1 === r.enablePan) return; if (u !== m.TOUCH_DOLLY_PAN) return; !function (e) { if (r.enableZoom) { var t = e.touches[0].pageX - e.touches[1].pageX, n = e.touches[0].pageY - e.touches[1].pageY, o = Math.sqrt(t * t + n * n); P.set(0, o), j.set(0, Math.pow(P.y / w.y, r.zoomSpeed)), S(j.y), w.copy(P) } if (r.enablePan) { var a = .5 * (e.touches[0].pageX + e.touches[1].pageX), i = .5 * (e.touches[0].pageY + e.touches[1].pageY); H.set(a, i), O.subVectors(H, R).multiplyScalar(r.panSpeed), N(O.x, O.y), R.copy(H) } r.update() }(e); break; default: u = m.NONE } } function K(e) { !1 !== r.enabled && (r.dispatchEvent(l), u = m.NONE) } function _(e) { !1 !== r.enabled && e.preventDefault() } r.domElement.addEventListener("contextmenu", _, !1), r.domElement.addEventListener("mousedown", U, !1), r.domElement.addEventListener("wheel", Y, !1), r.domElement.addEventListener("touchstart", I, !1), r.domElement.addEventListener("touchend", K, !1), r.domElement.addEventListener("touchmove", X, !1), window.addEventListener("keydown", Z, !1), this.update() }, THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype), THREE.OrbitControls.prototype.constructor = THREE.OrbitControls, Object.defineProperties(THREE.OrbitControls.prototype, { center: { get: function () { return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target } }, noZoom: { get: function () { return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom }, set: function (e) { console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !e } }, noRotate: { get: function () { return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate }, set: function (e) { console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !e } }, noPan: { get: function () { return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan }, set: function (e) { console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !e } }, noKeys: { get: function () { return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys }, set: function (e) { console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !e } }, staticMoving: { get: function () { return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping }, set: function (e) { console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !e } }, dynamicDampingFactor: { get: function () { return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor }, set: function (e) { console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = e } } });